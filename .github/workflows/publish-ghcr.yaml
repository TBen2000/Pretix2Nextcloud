name: Build & Publish Docker Images

on:
  push:
    branches:
      - main

  workflow_dispatch:

jobs:

  # ------------------------------------------------------------------
  # JOB 1: Evaluate what to build
  # ------------------------------------------------------------------
  target-selector:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      should_run: ${{ steps.set-matrix.outputs.should_run }}
    steps:
      - uses: actions/checkout@v4

      - name: Check for file changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            global:
              - 'P2N.py'
              - 'requirements.txt'
              - '.github/workflows/publish-ghcr.yaml'
            jungschartag:
              - 'kv-stuttgart_jungschartag/**'
            teencamp:
              - 'kv-stuttgart_teencamp/**'
            zeltlager_jungs:
              - 'kv-stuttgart_zeltlager-jungs/**'
            zeltlager_maedels:
              - 'kv-stuttgart_zeltlager-maedels/**'

      - name: Generate Matrix
        id: set-matrix
        shell: python
        # WICHTIG: Hier übergeben wir das JSON als Environment Variable
        env:
          CHANGES_JSON: ${{ toJson(steps.changes.outputs) }}
        run: |
          import json
          import os

          # Konfiguration deiner Images
          all_images = [
            {"id": "jungschartag",      "folder": "kv-stuttgart_jungschartag",      "name": "kv-stuttgart-jungschartag"},
            {"id": "teencamp",          "folder": "kv-stuttgart_teencamp",          "name": "kv-stuttgart-teencamp"},
            {"id": "zeltlager_jungs",   "folder": "kv-stuttgart_zeltlager-jungs",   "name": "kv-stuttgart-zeltlager-jungs"},
            {"id": "zeltlager_maedels", "folder": "kv-stuttgart_zeltlager-maedels", "name": "kv-stuttgart-zeltlager-maedels"}
          ]

          # Daten sicher aus der Umgebungsvariable laden
          try:
              changes = json.loads(os.environ['CHANGES_JSON'])
              print(f"Detected changes: {changes}")
          except Exception as e:
              print(f"Error parsing JSON: {e}")
              changes = {}

          final_list = []
          
          # LOGIK: Global oder Workflow Dispatch -> Alles bauen
          is_global = changes.get('global') == 'true'
          is_manual = '${{ github.event_name }}' == 'workflow_dispatch'

          if is_global or is_manual:
              print("Global change or manual dispatch detected. Building ALL images.")
              final_list = all_images
          else:
              # Sonst: Nur geänderte Ordner
              for img in all_images:
                  if changes.get(img['id']) == 'true':
                      final_list.append(img)

          # Output setzen
          if len(final_list) > 0:
              print(f"Building images: {[i['name'] for i in final_list]}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
                  # JSON muss für den Output wieder als String ohne Newlines formatiert werden
                  fh.write(f"matrix={json.dumps(final_list)}\n")
                  fh.write("should_run=true\n")
          else:
              print("No relevant changes detected.")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
                  fh.write("should_run=false\n")

  # ------------------------------------------------------------------
  # JOB 2: Build (runs dynamically based on Job 1)
  # ------------------------------------------------------------------
  build-and-push:
    needs: target-selector
    if: needs.target-selector.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.target-selector.outputs.matrix) }}

    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Login to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      # --------------------------------------------------------------
      # Generic build process (Variables are retrieved from the matrix)
      # --------------------------------------------------------------
      
      - name: Build base image -> ${{ matrix.name }}
        run: |
          IMAGE=ghcr.io/${{ github.repository_owner }}/pretix2nextcloud-${{ matrix.name }}
          # Kleinschreibung erzwingen (Docker mag keine Großbuchstaben)
          IMAGE=$(echo $IMAGE | tr '[:upper:]' '[:lower:]')
          
          DOCKERFILE=${{ matrix.folder }}/Dockerfile

          echo "Building Base: $IMAGE:base using $DOCKERFILE"

          docker build . \
            -f $DOCKERFILE \
            --tag $IMAGE:base

      - name: Push base image -> ${{ matrix.name }}
        id: push_base
        run: |
          IMAGE=ghcr.io/${{ github.repository_owner }}/pretix2nextcloud-${{ matrix.name }}
          IMAGE=$(echo $IMAGE | tr '[:upper:]' '[:lower:]')

          docker push $IMAGE:base | tee output.txt
          DIGEST=$(grep -o 'sha256:[a-f0-9]\+' output.txt | head -n 1)
          
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Build final image with digest -> ${{ matrix.name }}
        run: |
          IMAGE=ghcr.io/${{ github.repository_owner }}/pretix2nextcloud-${{ matrix.name }}
          IMAGE=$(echo $IMAGE | tr '[:upper:]' '[:lower:]')
          
          DIGEST="${{ steps.push_base.outputs.digest }}"

          echo "Injecting Digest: $DIGEST"

          # Hier wird dein Injektions-Trick angewendet
          echo "FROM $IMAGE:base" > Dockerfile.inject
          echo "ENV DOCKER_IMAGE=$DIGEST" >> Dockerfile.inject

          docker build . \
            -f Dockerfile.inject \
            --tag $IMAGE:latest

      - name: Push final image -> ${{ matrix.name }}
        run: |
          IMAGE=ghcr.io/${{ github.repository_owner }}/pretix2nextcloud-${{ matrix.name }}
          IMAGE=$(echo $IMAGE | tr '[:upper:]' '[:lower:]')
          
          docker push $IMAGE:latest